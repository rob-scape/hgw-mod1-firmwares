/*
  Enhanced Bernoulli Gate and Loop Sequencer with Glitch Bursts for Hagiwos Mod1 for Arduino Nano by Rob Heel.
  ------------------------------------------------------
  This code implements a Bernoulli gate function with an optional step sequence mode and Glitch Bursts. 
  The mode is controlled by Pot2. Behavior:

  Pot1 : Bernoulli Gate on output F3/ F4. Pot 1 sets probability which output is used from trigger in on F1. F2 is CV in for pot1. 

  Pot2 (A1) Modes:
  - Fully Counterclockwise (0-20%): Bernoulli Mode (random coin toss)
  - 20-40%: 4-Step Sequence
  - 40-60%: 8-Step Sequence
  - 60-80%: 16-Step Sequence
  - 80-100%: 32-Step Sequence

  Pot3 (A2) - Miss Probability and Glitch Burst:
  - Fully Counterclockwise: No missed triggers, no glitch bursts
  - Turn Clockwise: Up to 35% of triggers are missed. Linear behavior 0-35%. 
  - 80-100%: Glitch Bursts introduced (random rapid trigger bursts)

  The sequence can be regenerated by pressing the button.

  Pin Configuration:
  ------------------
  Potentiometer 1 (Probability) - A0
  Potentiometer 2 (Mode/Length) - A1
  Potentiometer 3 (Miss Probability/Glitch) - A2
  Trigger Input                 - A3 (F1)
  CV Input (0-5V)               - A4 (F2)
  Output 1 (F3)                 - D10
  Output 2 (F4)                 - D11
  LED                           - D3
  Button                        - D4
*/

const int trigInputPin = A3;   // Trigger Input Pin
const int cvInputPin = A4;     // CV Input Pin (F2)
const int potPin = A0;         // Potentiometer 1 (Probability) - Input Pin
const int lengthPotPin = A1;   // Potentiometer 2 (Sequence Length/Mode) - Input Pin
const int missPotPin = A2;     // Potentiometer 3 (Miss Probability/Glitch) - Input Pin
const int outputPinF3 = 10;    // Output Pin F3
const int outputPinF4 = 11;    // Output Pin F4
const int ledPin = 3;          // LED Pin
const int buttonPin = 4;       // Button Pin to trigger sequence generation
const unsigned long pulseDuration = 20;  // Pulse Duration for LED and Output High

int probability = 512;          // Probability value based on Pot 1
int combinedProbability = 512; // Combined probability with CV input
int cvValue = 0;               // CV input value
bool trigState = LOW;          // Current state of trigger input
bool lastTrigState = LOW;      // Last state of trigger input (to detect rising edge)
unsigned long pulseStartTime = 0;   // Time when the pulse starts
bool pulseActive = false;      // Flag for pulse activation
int outputPin = outputPinF3;  // Default output pin (F3)

int sequenceLength = 0;        // Length of the sequence (based on Pot2)
int sequenceStep = 0;          // Current step in the sequence
int sequence[32];              // Array to store the sequence of outputs
bool inSequenceMode = false;   // Flag for sequence mode

unsigned long lastTriggerTime = 0; // Last time a trigger event occurred

// Function to generate a new sequence based on Pot2 (length) and Pot1 (probability)
void generateSequence(int length) {
  for (int i = 0; i < length; i++) {
    int coinToss = random(0, 1023);
    // Based on coin toss, decide if F3 or F4 will be used for this sequence step
    if (coinToss < combinedProbability) {
      sequence[i] = outputPinF3;
    } else {
      sequence[i] = outputPinF4;
    }
  }
}

// Setup function to initialize all pins and random seed
void setup() {
  pinMode(trigInputPin, INPUT);      // Trigger input pin
  pinMode(cvInputPin, INPUT);        // CV input pin (F2)
  pinMode(potPin, INPUT);            // Potentiometer 1 (Probability)
  pinMode(lengthPotPin, INPUT);      // Potentiometer 2 (Sequence Length/Mode)
  pinMode(missPotPin, INPUT);        // Potentiometer 3 (Miss Probability/Glitch)
  pinMode(outputPinF3, OUTPUT);      // Output pin F3
  pinMode(outputPinF4, OUTPUT);      // Output pin F4
  pinMode(ledPin, OUTPUT);           // LED output pin
  pinMode(buttonPin, INPUT_PULLUP);  // Button pin with pull-up resistor

  randomSeed(analogRead(A7));  // Initialize random seed from unused pin A7
  digitalWrite(ledPin, LOW);   // Ensure LED starts off
}

// Function to generate a glitch burst on the outputs
// A glitch burst is a rapid series of outputs (F3 and F4) with random delays
void glitchBurst(unsigned long interval) {
  int burstLength = random(3, 10);
  unsigned long burstDelay = interval / random(2, 5); // Fraction of the trigger interval
  for (int i = 0; i < burstLength; i++) {
    // Choose between F3 and F4 based on the probability (Pot 1)
    int coinToss = random(0, 1023); // Coin toss based on Pot 1 probability
    int output = (coinToss < combinedProbability) ? outputPinF4 : outputPinF3; 

    digitalWrite(output, HIGH);
    delay(burstDelay);
    digitalWrite(output, LOW);
    delay(burstDelay);
  }
}



// Main loop function
void loop() {
  trigState = digitalRead(trigInputPin);  // Read the trigger input

  // Determine sequence length and mode based on Pot2 (lengthPotPin)
  int lengthValue = analogRead(lengthPotPin);
  if (lengthValue < 200) {
    sequenceLength = 0;
    inSequenceMode = false;
  } else if (lengthValue < 400) {
    sequenceLength = 4;
    inSequenceMode = true;
  } else if (lengthValue < 600) {
    sequenceLength = 8;
    inSequenceMode = true;
  } else if (lengthValue < 800) {
    sequenceLength = 16;
    inSequenceMode = true;
  } else {
    sequenceLength = 32;
    inSequenceMode = true;
  }

  // Generate sequence when the button is pressed
  if (digitalRead(buttonPin) == LOW) {
    generateSequence(sequenceLength);
    sequenceStep = 0;
  }

  // Check for rising edge of trigger (i.e., when trigger goes from LOW to HIGH)
  if (trigState == HIGH && lastTrigState == LOW) {
    unsigned long currentTime = millis();
    unsigned long interval = currentTime - lastTriggerTime;  // Time since last trigger
    lastTriggerTime = currentTime;  // Update last trigger time

    // Read Pot1 (Probability) and adjust based on CV input (F2)
    probability = analogRead(potPin);
    if (inSequenceMode) {
      probability = 1023 - probability;  // Reverse probability for sequence mode
    }
    cvValue = analogRead(cvInputPin);
    combinedProbability = constrain(probability + cvValue, 0, 1023);  // Combine values

    // Miss Probability: Read Pot3 (missPotPin) to determine chance of missing trigger
    int missProbability = map(analogRead(missPotPin), 0, 1023, 0, 350);
    if (random(0, 1000) < missProbability) {
      lastTrigState = trigState;
      return;  // Skip if trigger is missed
    }

    // Glitch Burst Probability: Determine chance of a glitch burst occurring
    int glitchThreshold = map(analogRead(missPotPin), 820, 1023, 0, 20);
    if (random(0, 100) < glitchThreshold) {
      glitchBurst(interval);  // Call glitchBurst function to create random glitch bursts
    }

    // Handle sequence mode or Bernoulli mode
    int coinToss;
    if (inSequenceMode) {
      coinToss = random(0, 1023);
      outputPin = sequence[sequenceStep];  // Use pre-generated sequence
      sequenceStep = (sequenceStep + 1) % sequenceLength;  // Move to next step in sequence
    } else {
      coinToss = random(0, 1023);
      outputPin = (coinToss < combinedProbability) ? outputPinF4 : outputPinF3;
    }

    // Activate output and LED
    digitalWrite(outputPin, HIGH);
    digitalWrite(ledPin, HIGH);
    pulseStartTime = millis();
    pulseActive = true;
  }

  // Manage pulse duration: Turn off outputs and LED after pulseDuration
  if (pulseActive && millis() - pulseStartTime >= pulseDuration) {
    digitalWrite(outputPin, LOW);
    digitalWrite(ledPin, LOW);
    pulseActive = false;
  }

  lastTrigState = trigState;  // Update last trigger state for next loop iteration
}
